#$#$0 (+-*/)   FLAG LINE FOR SMALL MACRO COMPILER -- OCT 10, 1981
$#                           ACCEPT AN INPUT LINE (C) 1981 BY CR BRITTEN
*LN$26 .SET *LN=$21+1#         BUMP UP LINE NUMBER
$21$26 *LEV$36 $31$36#	       RECALL LEVEL NUMBER
$F14#			       PRINT LINE NUMBER LEVEL AND 72 CHAR LINE
2222 33 111111111111111111111111111111111111111111111111111111111111111111111111
.INT $10#		       INTERMEDIATE LANGUAGE OUTPUT
.TLB $10#		       TRIM LEADING BLANKS
*TRIM$96 .STM $91#	       PARSE TRIMMED LINE AS STATEMENT
# 1 --------------- STATEMENT PARSERS                ----------------
.STM $BEGIN $ $#	     BEGIN MODULE AND INITIALIZE
.BGN#			       PROCESS BEGIN STATMENENT
.STM $30#		       NEXT STATEMENT
# 2
.STM $BEGIN $;$#	     BEGIN MODULE WITH SEMICOLON
.BGN#			       PROCESS BEGIN STATMENENT
.STM $30#		       NEXT STATEMENT
# 3
.STM $BEGIN$#		     BEGIN STATEMENT WITHOUT MODULE NAME
.BGN#			       PROCESS BEGIN STATMENENT
.STM $20#		       NEXT STATEMENT
# 4
.STM $START $ $#	     START EXECUTION AT LABEL
.STRT $20#		       PROCESS START LABEL
.STM $30#		       NEXT STATEMENT
# 5
.STM $START $;$#	     START EXECUTION AT LABEL WITH SEMICOLON
.STRT $20#		       PROCESS START LABEL
.STM $30#		       NEXT STATEMENT
# 6
.STM $STOP$#		     STOP EXECUTION, CLOSE FILES, GO TO OPSYS
. CALL EXIT#
# 7
.STM $=$;$#		     ASSIGNMENT STATEMENT
.INIT#			       INITIALIZE ARITHMETIC EXPRESSION ANALYZER
.VAR $10#		       VARIABLE ON LEFT HAND SIDE
.UEX $20#		       COMPILE UNARY ARITHMETIC EXPRESSION
.QUE *POS,.BNST#	       BINARY NON-COMMUTATIVE STORE
*POS$96 .GEN $91#	       GENERATE CODE FROM POSTFIX
.STM $30#		       NEXT STATEMENT
# 8
.STM $IF $;$#		     IF CONDITIONAL
.CEXI $20#		       CONDITIONAL EXPRESSION
*POS$96 .GEN $91#	       GENERATE CODE FROM POSTFIX
*LEV$76 .SET *LEV=$71+1#       INC LEVEL NUMBER
.STM $30#		       NEXT STATEMENT
# 9
.STM $THEN $#		     THEN CLAUSE
*JUMP$96 . $91 LJ$01#	       RECALL CONDITIONAL JUMP
.STK *TARG,$01#		       STACK THE JUMP TARGET
.STM $20#		       NEXT STATEMENT
# 10
.STM $ELSE $#		     ELSE CLAUSE
. J LJ$01#		       JUMP AROUND FOR TRUE CONDITION
*TARG$96 .POPT $91#	       TARGET FOR FALSE CONDITION
.STK *TARG,$01#		       STACK THE JUMP TARGET
.STM $20#		       NEXT STATEMENT
# 11
.STM $ENDIF$#		     END OF THEN OR ELSE CLAUSE
*TARG$96 .POPT $91#	       TARGET LABEL
*LEV$76 .SET *LEV=$71-1#       DEC LEVEL NUMBER
.STM $20#		       NEXT STATEMENT
# 12
.STM $EXIT$#		     EXIT FROM THEN, ELSE, WHILE OR REPEAT
*TARG$96 .EXIT $91#	       RECALL EXIT LABEL
.STM $20#		       NEXT STATEMENT
# 13
.STM $DO WHILE $;$#	     DO-WHILE CONDITIONAL
.LABEL LJ$01#		       LOOP TARGET
.STK *LOOP,$01#		       STACK LOOP TARGET
.CEXI $20#		       CONDITIONAL EXPRESSION
*POS$96 .GEN $91#	       GENERATE CODE FROM POSTFIX
*JUMP$96 . $91 LJ$02#	       COND JUMP TO EXIT TARGET
.STK *TARG,$02#		       STACK EXIT TARGET
*LEV$76 .SET *LEV=$71+1#       INC LEVEL NUMBER
.STM $30#		       NEXT STATEMENT
# 14
.STM $ENDDO$#		     END DO-WHILE
*LOOP$96 .POPL J,$91#	       RECALL LOOP TARGET AND JUMP
*TARG$96 .POPT $91#	       RECALL EXIT TARGET LABEL
*LEV$76 .SET *LEV=$71-1#       DEC LEVEL NUMBER
.STM $20#		       NEXT STATEMENT
# 15
.STM $REPEAT $#		     REPEAT-UNTIL OPENING STATEMENT
.LABEL LJ$01#		       LOOP TARGET
.STK *LOOP,$01#		       STACK LOOP TARGET
.STK *TARG,$02#		       STACK EXIT TARGET
*LEV$76 .SET *LEV=$71+1#       INC LEVEL NUMBER
.STM $20#		       NEXT STATEMENT
# 16
.STM $UNTIL $;$#	     UNTIL CONDITIONAL
.CEXI $20#		       CONDITIONAL EXPRESSION
*POS$96 .GEN $91#	       GENERATE CODE FROM POSTFIX
*LOOP$96 *JUMP$86 .POPL $81,$91# RECALL LOOP AND COND JUMP
*TARG$96 .POPT $91#	       RECALL EXIT TARGET LABEL
*LEV$76 .SET *LEV=$71-1#       DEC LEVEL NUMBER
.STM $30#		       NEXT STATEMENT
# 17
.STM $CASE $;$#		     CASE STATEMENT
.CEXI $20#		       CONDITIONAL EXPRESSION
*POS$96 .GEN $91#	       GENERATE CODE FROM POSTFIX
*LEV$76 .SET *LEV=$71+1#       INC LEVEL NUMBER
.STM $30#		       NEXT STATEMENT
# 18
.STM $OF $;$#		     CASE LABELLIST
.CASL $01,$20#		       CASE LABEL LIST FILED AWAY
.STK *TARG,$01#		       STACK THE TARGET FOR EXIT
.STM $30#		       NEXT STATEMENT
# 19
.STM $ENDCAS$ $#	     END OF CASE STATEMENT
*TARG$96 .POPT $91#	       RECALL EXIT TARGET LABEL
*LEV$76 .SET *LEV=$71-1#       DEC LEVEL NUMBER
.STM $30#		       NEXT STATEMENT
# 20
.STM $DCL $;$#		     DECLARATION STATEMENT
. SECT DATA#		       CRB 08/23/2007
$20$27,#		       SPLIT DCL LIST ON COMMA
.DCL $20#		       HANDLE EACH DECLARED ITEM
$F8#			       REPEAT UNTIL LIST EMPTY
.STM $30#		       NEXT STATEMENT
# 21
.STM $DECLARE $;$#	     DECLARATION STATEMENT
. SECT DATA#		       CRB 08/23/2007
$20$27,#		       SPLIT DCL LIST ON COMMA
.DCL $20#		       HANDLE EACH DECLARED ITEM
$F8#			       REPEAT UNTIL LIST EMPTY
.STM $30#		       NEXT STATEMENT
# 22
.STM $MSG $=$'$'$#	     MESSAGE DECLARATION
. SECT DATA#		       CRB 08/23/2007
.LABEL $20#
. CONST $45#		       MESSAGE LENGTH
$40$47#			       GENERATE ONE CHARACTER PER WORD
. CONST $48#
$F8#
.STM $50#		       NEXT STATEMENT
# 23
.STM $MESSAGE $=$'$'$#	     MESSAGE DECLARATION
.STM MSG $20='$40'#
.STM $50#		       NEXT STATEMENT
# 24
.STM $GO TO $ $#	     GO TO STATEMENT
. J $20#		       JUMP TO LABEL
.STM $30#		       NEXT STATEMENT
# 25
.STM $GO TO $;$#	     GO TO STATEMENT WITH SEMICOLON
. J $20#		       JUMP TO LABEL
.STM $30#		       NEXT STATEMENT
# 26
.STM $LABEL $ $#	     LABEL STATEMENT
. SECT CODE#		       CRB 08/23/2007
.IFC $20#		       IF CASE LABEL
.LABEL $20#
.STM $30#		       NEXT STATEMENT
# 27
.STM $LABEL $;$#	     LABEL STATEMENT WITH SEMICOLON
. SECT CODE#		       CRB 08/23/2007
.IFC $20#		       IF CASE LABEL
.LABEL $20#
.STM $30#		       NEXT STATEMENT
# 28
.STM $CALL $ $#		     CALL STATEMENT
. CALL $20#
.STM $30#		       NEXT STATEMENT
# 29
.STM $CALL $;$#		     CALL STATEMENT WITH SEMICOLON
. CALL $20#
.STM $30#		       NEXT STATEMENT
# 30
.STM $PROC$ $ $#	     PROCEDURE DECLARATION
.PROC $30#		       PROCESS PROCEDURE SETUP
.STM $40#		       NEXT STATEMENT
# 31
.STM $PROC$ $;$#	     PROCEDURE DECLARATION WITH SEMICOLON
.PROC $30#		       PROCESS PROCEDURE SETUP
.STM $40#		       NEXT STATEMENT
# 32
.STM $REC$ PROC$ $ $#	     RECURSIVE PROCEDURE DECLARATION
.RPROC $40#		       PROCESS PROCEDURE SETUP
.STM $50#		       NEXT STATEMENT
# 33
.STM $REC$ PROC$ $;$#	     REC PROCEDURE DECLARATION WITH SEMICOLON
.RPROC $40#		       PROCESS PROCEDURE SETUP
.STM $50#		       NEXT STATEMENT
# 34
.STM $RETURN $;$#	     RETURN STATEMENT
.INIT#
.UEX $20#		       COMPILE EXPRESSION
*POS$96 .GEN $91#	       GENERATE EXPRESSION CODE
*RECPRC$76#		       RECALL RECURSIVE PROC FLAG
*NPARS$86 *RID$96#	       RECALL RETURN ID AND NUMBER OF PARAMS
. $71RETN $91,$81#
.STM $30#		       NEXT STATEMENT
# 35
.STM $RETURN$#		     RETURN FROM SUBROUTINE
*RECPRC$76#		       RECALL RECURSIVE PROC FLAG
*NPARS$86 *RID$96#	       RECALL RETURN ID AND NUMBER OF PARAMS
. $71RETN $91,$81#
.STM $20#		       NEXT STATEMENT
# 36
.STM $ENDPROC$#		     END PROCEDURE
.ALLOC#			       ALLOCATE ANY TEMPORARIES
*PARLIST$96#		       RECALL THE PARAMETER LIST
*LEV$76 .SET *LEV=$71-1#       DEC LEVEL NUMBER
.IF $91= SKIP 3#
$91$87,#		       BREAK PARAMETER LIST ON COMMA
.LET $80=#		       AND NULL EACH ONE OUT
$F8#
.LET *RECPRC=#		       NULL THE RECURSIVE PROC FLAG
.STM $20#		       NEXT STATEMENT
# 37
.STM $ENT$ $;$#		     GLOBAL ENTRY POINTS FOR THIS MODULE
$30$37,#		       BREAK PARAMETER LIST ON COMMA
. ENT $30#		       ISSUE PSEUDO-OP FOR EACH ENTRY
$F8#
.STM $40#		       NEXT STATEMENT
# 38
.STM $EXT$ $;$#		     GLOBAL EXTERNAL ENTRY POINTS
$30$37,#		       BREAK PARAMETER LIST ON COMMA
.EXT $30#		       PROCESS EACH EXTERNAL
$F8#
.STM $40#		       NEXT STATEMENT
# 39
.STM $SET $=$;$#	     SET COMPILE TIME VALUE
.LET $20=$34#
.STM $40#		       NEXT STATEMENT
# 40
.STM $END$#		     END OF MODULE
.ALLOC#			       ALLOCATE ANY TEMPORARIES
*LEV$76 .IF $71 EQ 0 SKIP 2#
 LEVEL ERROR $71$F14#
*NERRS$96 .SET *NERRS=$91+1#
*NERRS$86  $81 ERRORS DETECTED$F14#
. END#			       END ASSEMBLY LANGUAGE MODULE
$F0#			       TERMINATE STAGE2
# 41
.STM $;$#		     DISCARD STRAY SEMICOLON
.STM $20#		       NEXT STATEMENT
# 42
.STM $*$#		     COMMENT TO END OF LINE
# 43
.STM #			     ABSORB THE NULL STATEMENT
# 44
.STM $#			     NO KEYWORD RECOGNIZED
THE FOLLOWING STATEMENT NOT RECOGNIZED$F14#
$10$F14#
*NERRS$96 .SET *NERRS=$91+1#
# 45
.STM  $#		     TRIM LEADING BLANKS
.TLB $10#
*TRIM$96 .STM $91#
# 46 --------------- CONDITIONAL EXPRESSION PARSERS    ---------------
.INIT#			     INITIALIZE ARITHMETIC EXPRESSION ANALYZER
.LET *TMP=0#		       RESET TEMPORARY STORAGE COUNTER
.LET *POS=#		       NULL THE POSTFIX QUEUE
.LET *OPN=#		       NULL THE OPERAND STACK
.LET *CC=#		       CONDITION CODES NOT SET
# 47
.CEXI $#		     CONDITIONAL EXPRESSION INITIALIZE
.INIT#			       INITIALIZE THE ANALYZER
.CEX $10#		       COMPILE CONDITIONAL EXPRESSION
# 48
.CEX $#			     CONDITIONAL EXPRESSION ANALYSIS
.LET *JUMP=JEQ#		       JUMP IF ACC=0 AFTER EXP
.UEX $10-0#                    set ALU flags CRB 12/30/2013
# 49
.CEX $ EQ $#		     EQUAL
.LET *JUMP=JNE#
.UEX $10-($20)#
# 50
.CEX $ NE $#		     NOT EQUAL
.LET *JUMP=JEQ#
.UEX $10-($20)#
# 51
.CEX $ LT $#		     LESS THAN
.LET *JUMP=JGE#
.UEX $10-($20)#
# 52
.CEX $ GE $#		     GREATER THAN OR EQUAL
.LET *JUMP=JLT#
.UEX $10-($20)#
# 53
.CEX $ LE $#		     LESS THAN OR EQUAL
.LET *JUMP=JGT#
.UEX $10-($20)#
# 54
.CEX $ GT $#		     GREATER THAN
.LET *JUMP=JLE#
.UEX $10-($20)#
# 55 --------------- UNARY ARITHMETIC OPERATION PARSERS ---------------
.UEX $#		             NO UNARY OPERATOR
.EXP, $10#
# 56
.UEX +$#		     UNARY PLUS DELETED
.EXP, $10#
# 57
.UEX -$#		     UNARY MINUS OPERATOR
.EXP.U-, $10#
# 58 --------------- EXPRESSION PARSERS                 ---------------
.EXP$, $#		     ARITHMETIC EXPRESSION
.TRM, $20#
.QUE *POS,$10#
# 59
.EXP$, $+$#		     BINARY COMMUTATIVE ADD
.TRM, $20#
.QUE *POS,$10#
.EXP.BC+, $30#
# 60
.EXP$, $-$#		     BINARY NON-COMMUTATIVE SUBTRACT
.TRM, $20#
.QUE *POS,$10#
.EXP.BN-, $30#
# 61
.EXP$, $ OR $#		     BINARY COMMUTATIVE INCLUSIVE OR
.TRM, $20#
.QUE *POS,$10#
.EXP.BCOR, $30#
# 62
.EXP$, $ XOR $#		     BINARY COMMUTATIVE EXCLUSIVE XOR
.TRM, $20#
.QUE *POS,$10#
.EXP.BCXOR, $30#
# 63 --------------- TERM PARSERS                      ----------------
.TRM$, $#
.PRI $20
.QUE *POS,$10#
# 64
.TRM$, $*$#		     BINARY COMMUTATIVE MULTIPLY
.PRI $20#
.QUE *POS,$10#
.TRM.BC*, $30#
# 65
.TRM$, $/$#		     BINARY NON-COMMUTATIVE DIVIDE
.PRI $20#
.QUE *POS,$10#
.TRM.BN/, $30#
# 66
.TRM$, $ MOD $#		     BINARY NON-COMMUTATIVE MODULUS
.PRI $20#
.QUE *POS,$10#
.TRM.BNMOD, $30#
# 67
.TRM$, $ AND $#		     BINARY COMMUTATIVE AND
.PRI $20#
.QUE *POS,$10#
.TRM.BCAND, $30#
# 68
.TRM$, $ SH$ $#		     BINARY NON-COMMUTATIVE SHIFT
.PRI $20#
.QUE *POS,$10#
.TRM.BNSH$30, $40#
# 69 --------------- PRIMARY PARSERS                   ---------------
.PRI $#			    PRIMARY OPERAND
$10$871234567890#	      BREAK OPERAND ON DIGIT
.IF $80= SKIP 2#
.QUE *POS,$10#		      QUEUE AN IDENTIFIER OPERAND
$F9#			      IMMEDIATE EXIT FROM LOOP AND MACRO
.QUE *POS,=$10#		      QUEUE NUMERIC OPERAND AS IMMEDIATE
# 70
.PRI ($)#		     RECURSIVE SUBEXPRESSION
.UEX $10#
# 71
.PRI $($)#		     ARRAY REFERENCE OR FUNCTION CALL
.IF $11=P SKIP 3#	       TEST FOR PROCEDURE TAG
.VAR $10($20)#		       PROCESS ARRAY VARIABLE
.QUE *POS,.UA#
$F9#
.QUE *POS,($20),.UF$10#	       QUEUE ARG LIST AND FUNCTION CALL
# 72
.PRI NOT $#		     UNARY LOGICAL INVERSION OF EACH BIT
.PRI $10#
.QUE *POS,.UNOT#
# 73
.PRI '$'#		     LITERAL CHARACTER
.QUE *POS,=$18#		       QUEUE CHAR CODE AS IMMED OPERAND
# 74 --------------- VARIABLE PARSERS                 ---------------
.VAR $#		             SCALAR VARIABLE
.QUE *POS,=$10#
# 75
.VAR $($)#		     ARRAY ELEMENT
.EXP, =$10+($20) SHL 2#	       EVALUATE ARRAY REFERENCE CRB for 32-bit
# 76 --------------- STACKING AND QUEUEING            ---------------
.STK $,$#		     STACK P2 ON STACK NAMED P1
$20,$11$26 $F3#
# 77
.QUE $,$#		     QUEUE P2 ON THE QUEUE NAMED P1
$11$20,$26 $F3#
# 78
.QUE $,#		     IGNORE NULL STRING QUEUE
# 79
.POPT $,$#		     POP TARGET LABEL
.LABEL LJ$10#		       GENERATE THE LABEL
.LET *TARG=$20#		       REST OF STACK
# 80
.POPL $,$,$#		     POP LOOP LABEL AND JUMP CONDITIONALLY
. $10 LJ$20#
.LET *LOOP=$30#
# 81
.LABT $,$#		     JUMP TO CASE EXIT LABEL ON TOP OF STACK
. J LJ$10#
# 82
.EXIT $,$,$#		     EXIT TO OUTER LEVEL
. J LJ$20#
# 83 --------------- CODE GENERATORS                 ----------------
.GEN $#			     GENERATE CODE FROM POSTFIX STRING
.INT .GEN $10#		       PRINT OUT CALL IN INTERMEDIATE CODE
$10$27,#		       BREAK ON COMMA TO GET POSTFIX TOKEN
$20$37.#		       BREAK TOKEN ON PERIOD TO CHECK FOR OPERATORS
.IF $30= SKIP 2#
.STK *OPN,$20#		       STACK OPERAND
.SKIP 3#
*OPN$96 $20 $91#	       PROCESS OPERATOR
.SKIP 1#
$F8#			       TERMINATE BREAK ON PERIOD
$F8#			       LOOP ON COMMA UNTIL POSTFIX EMPTY
*OPN$96 .IF $91= SKIP 2#       CHECK FOR NULL OPND STACK
.IF $91=.AC, SKIP 1#	       IGNORE STACKED ACCUM
. L $91#		       LOAD A LONE OPERAND
# 84
.BC$ .AC,$,$#		     COMMUTATIVE OP ON ACCUM
. $10 $20#		       APPLY OP TO 2ND OPND
.LET *OPN=.AC,$30#	       STACK .AC
# 85
.BN$ .AC,$,$#		     NON-COMMUTATIVE OP ON ACCUMULATOR
*TSET$76#		       RECALL CURRENT TEMP SET NUMBER
. ST T$71Z#		       SAVE ACCUM IN TEMP
. L $20#		       LOAD 2ND OPERAND
. $10 T$71Z#		       APPLY OP TO TEMP
.LET *OPN=.AC,$30#	       STACK .AC
.LET *TUSE=1#		       NOTE TNZ IN USE
# 86
.BC$ $,$,$#		     FIRST OPND IS NOT ACCUM
.LET *OPN=$40#		       POP 2 OPNDS OFF STACK
.IF $30=.AC SKIP 2#	       SKIP IF 2ND OPND IS ACCUM
.ACB $40#		       MODIFY STACK IF ACCUM IS BUSY
. L $30#		       LOAD NEW OPND INTO ACCUM
. $10 $20#		       APPLY OP TO 1ST OPND
.STK *OPN,.AC#
# 87
.BN$ $,$,$#		     FIRST OPND IS NOT ACCUM
.LET *OPN=$40#		       POP 2 OPNDS OFF STACK
.IF $30=.AC SKIP 2#	       SKIP IF 2ND OPND IS ACCUM
.ACB $40#		       MODIFY STACK IF ACCUM IS BUSY
. L $30#		       LOAD NEW OPND INTO ACCUM
. $10 $20#		       APPLY OP TO 1ST OPND
.STK *OPN,.AC#
# 88
.UF$ $,$#		     FUNCTION CALL UNARY OP
.LET *OPN=$30#		       POP ONE OPND OFF STACK
.ACB $30#		       TAKE CARE OF BUSY ACCUM
. CALL $10$20#
.STK *OPN,.AC#
# 89
.U$ .AC,$#		     UNARY OPERATOR ON ACCUM
. $10#
# 90
.U$ $,$#		     UNARY OPERATOR ON OPERAND
.LET *OPN=$30#		       POP ONE OPERAND OFF STACK
.ACB $30#		       STORE ACCUM IF BUSY
. L $20#		       APPLY UNARY OP TO ACCUM
. $10#
.STK *OPN,.AC#
# 91
.UA .AC,$#		     UNARY ARRAY REFERENCE
. L *.AC#		       ACCUM CONTAINS OPERAND ADDRESS
# 92
.ACB $.AC$#		     MODIFY STACK IF ACCUM BUSY
*TMP$96 .SET *TMP=$91+1#       BUMP TEMP COUNTER
*TMAX$86#
.IF $81 GT $91 SKIP 1#
.LET *TMAX=$91#
*TSET$76#		       REPLACE TEMP SET NUMBER
.LET *OPN=$10T$71Z$91$20#      REPLACE .AC REF BY TEMP REF
. ST T$71Z$91#		       STORE ACCUM IN TEMP
# 93
.ACB $#			     NO-OP IF ACCUM NOT BUSY
# 94
.BNST .AC,$,$#		     NON-COMMUTATIVE STORE RESULT FROM ACCUM
. ST *$10#
.LET *OPN=$20#
# 95
.BNST $,$,$#		     NON-COMMUTATIVE STORE
. L $10#
. ST *$20#
.LET *OPN=$30#
# 96
.BNST $,.AC,$#		     STORE, TARGET ADDRESS IN ACCUM
*TSET$76#		       RECALL TEMP SET NUMBER
. ST T$71Z#
. L $10#
. ST *T$71Z#
.LET *OPN=$20#
.LET *TUSE=1#		       NOTE TNZ IN USE
# 97 --------------- AUXILLIARY STATEMENT PROCESSORS  ---------------
.BGN#			     BEGIN MODULE AND INITIALIZE
.BEGIN#			       INITIALIZE MACHINE DEPENDENT CODE GEN
.LET *NERRS=NO#		       INITIALIZE ERROR COUNTER
.SET NO=0#		       TO ZERO
# 98
.STRT $#		     START DECLARATION
. ENT $10#		       DECLARE AS GLOBAL ENTRY POINT
. STRT $10#		       GENERATE START CODE IF ANY
# 99
.PROCI $#		     PROCEDURE ENTRY INITIALIZATION
.ALLOC#			       ALLOCATE ANY TEMPORARIES
.LET *NPARS=0#		       NUMBER OF PARAMETER VARIABLES
.LET *RID=$10#		       REMEMBER RETURN ID
.LET $10=P#		       RECORD TYPE PROC
*LEV$76 .SET *LEV=$71+1#       INC LEVEL NUMBER
# 100
.$PROC $#		     PROCEDURE DECLARATION
.PROCI $20#		       INITIALIZE
. SECT CODE#		       CRB 08/23/2007
.LET *RECPRC=$10#
. SUBR $20#
.IF $10= SKIP 1#
. RECUR $20#
. NPARS 0#
.LET *PARLIST=#		       NULL THE PARAMETER LIST
. PEND#			       PROC DEFINITION END
# 101
.$PROC $($)#		     PROCEDURE DECLARATION WITH PARAMETERS
. SECT CODE#		       CRB 08/23/2007
.PROCI $20#		       INITIALIZE
.LET *RECPRC=$10#
$30$37,#		       SPLIT PARAMETER LIST ON COMMA
*NPARS$96 .SET *NPARS=$91+1#   COUNT PARAMETER VARIABLES
$F8#
. SUBR $20#		       SUBROUTINE ENTRY
.IF $10= SKIP 1#
. RECUR $20#
*NPARS$96 . NPARS $91#	       NUMBER OF PARAMETER VARIABLES
$30$37,#
. PAR $30#		       ISSUE PSEUDO-OP FOR EACH PARAM
.LET $30=D#		       RECORD TYPE OF EACH PARAM
$F8#
.LET *PARLIST=$30,#	       SAVE THE PARAMETER LIST
. PEND#
# 102
.EXT PROC$ $#		     EXTERNAL PROCEDURE REFERENCE
.LET $20=P#		       MARK PROC TYPE
. EXT $20#
# 103
.EXT $#			     EXTERNAL REFERENCE
. EXT $10#
# 104
.EXT REC$ RETURN#	     EXTERNAL RECURSIVE RETURN STACK
. EXT SKSIZE#
. EXT SK#
# 105
. CALL $($)#		     PROCEDURE CALL WITH ARGS
.LET *NARGS=0#		       INIT ARG COUNT TO ZERO
.LET *NCALL=$01#	       SET UNIQUE NUMBER FOR THIS CALL
$20$27,#		       SCAN THROUGH THE ARG LIST
.EVAL $20#		       EVALUATE EACH ACTUAL PARAMETER
$F8#
. SCALL $10#		       CALL THE PROCEDURE
*NARGS$96 . NARGS $91#	       NUMBER OF ACTUAL PARAMETERS
.LET *NARGS=0#		       COUNT THEM AGAIN
$20$27,#		       SCAN THE ARG LIST AGAIN
. ARG $20#		       PUT AN ARG FOR EACH ACTUAL PARAM
$F8#
. CEND#			       END OF CALLING SEQUENCE
# 106
. CALL $#		     PROCEDURE CALL WITH NO ARGS
.LET *NARGS=0#
. SCALL $10#
. NARGS 0#		       NUMBER OF ACTUAL PARAMS IS ZERO
. CEND#
# 107
.EVAL $#		     EVALUATE AN ACTUAL PARAMETER
*NARGS$96 .SET *NARGS=$91+1#   COUNT IT
.IF $11= SKIP 1#	       SEE IF THE ACTUAL IS A FORMAL
. ARGT $10#		       IF SO ARRANGE A TRANSFER
# 108
.DCL  $#		     TRIM LEADING BLANKS
.DCL $10#
# 109A			       Added TLB macro CRB 09/08/2007
.DCL $($)#		     DECLARE AN ARRAY
.LABEL $10#		       NAME OF ARRAY
$24+1$26#		       RESERVE N+1 WORDS
. SPACE $24#		       SPACE FOR ARRAY, COMPILE TIME EXP
# 109
.DCL $=$#		     DECLARE INITIALIZED VARIABLE
.LABEL $10#		       NAME OF VARIABLE
. CONST $24#		       DATA WORD CONSTANT, COMPILE TIME EXP
# 110
.DCL $#			     DECLARE SCALAR VARIABLE
.LABEL $10#		       NAME OF VARIABLE
. SPACE 1#		       SPACE FOR VARIABLE
# 111
.DCL $=($)#		     DECLARE INITIALIZED ARRAY LIST
.LABEL $10#
$20$27,#
.DATA $20#
$F8#
# 112
.DCL REC$ RETURN($)#	     DECLARE RECURSIVE RETURN SPACE
. ENT SKSIZE#
. ENT SK#
. LABEL SKSIZE#
. CONST $24#
. LABEL SK#
. CONST 1#
$20-1$36 . SPACE $34#
# 113
.LABEL $#		     TRIM LEADING BLANKS FROM LABEL
. LABEL $10#
# 114
.DATA  $#		     TRIM LEADING BLANKS
.DATA $10#
# 115A			       Added TLB macro CRB 09/08/2007
.DATA $#		     DATA CONSTANT
$10$17,#
.CNST $10#
$F8#
# 115
.DATA '$'#		     CONVERT CHAR TO CONST
. CONST $18#
# 116
.DATA ($)#		     DATA SUBLIST
.DATA $10#
# 117
.CNST $#		     CONSTANT
. CONST $14#		       COMPILE TIME EXPRESSION
# 118
.CNST $*$#		     RECURSION ON REPEATED CONSTANT
$10$F7#
.DATA $20#
$F8#
# 119
.IFC $#
*CASN$76 *TARG$86 *CASL$71$96#
.IF $91= SKIP 4#
$91$27,#
.IF $10-=$20 SKIP 1#
.LABT $81#
$F8#
# 120
.CASL $,$#		     PROCESS CASE LABEL LIST
.LET *CASN=$10#
.LET *CASL$10=$20#
. JX $10#		       INDEXED JUMP THROUGH TABLE
$20$27,#
. JC $20#		       CASE TABLE ENTRY POINTS TO CASE LABEL
$F8#
# 121
. L $,#			     DANGLING COMMA ON LONE LOAD
. L $10#
# 122
. $ *=$#		     INDIRECT AND LITERAL CANCEL EACH OTHER
. $10 $20#
# 123
.ALLOC#			     ALLOCATE TEMPORARY STORAGE
*TSET$76#		       RECALL THE TEMP SET NUMBER
*TUSE$66#
.IF $61= SKIP 4#	       ALLOCATE TNZ IF USED CRB 09/06/2007
. SECT DATA#		       CRB 09/06/2007
.LABEL T$71Z#
. SPACE 2#		       CRB temp hack 07/03/2013
. SECT CODE#		       CRB 09/06/2007
.LET *TMP=1#
*TMAX$96#		       RECALL MAX NUMBER OF TEMPS
.IF $91 EQ 0 SKIP 8#	       SKIP IF MORE CRB 09/06/2007
. SECT DATA#		       CRB 09/06/2007
$91$F7#
*TMP$86#
.LABEL T$71Z$81#
. SPACE 1#		       SPACE FOR ONE TEMPORARY
.SET *TMP=$81+1#
$F8#
. SECT CODE#		       CRB 09/06/2007
.LET *TMP=0#
.LET *TUSE=#
.LET *TMAX=0#
.SET *TSET=$71+1#
# 124
.TLB            $#	     TRIM LEADING BLANKS
.TLB $10#
#
.TLB      $#
.TLB $10#
#
.TLB     $#
.TLB $10#
#
.TLB    $#
.TLB $10#
#
.TLB   $#
.TLB $10#
#
.TLB  $#
.TLB $10#
#
.TLB $#
.LET *TRIM=$10#
# --------------- STAGE2 SYSTEM MACROS                ---------------
.IF $=$ SKIP $#
$F50#
#
.IF $-=$ SKIP $#
$F51#
#
.IF $ EQ $ SKIP $#
$F60#
#
.IF $ GT $ SKIP $#
$F6+#
#
.SKIP $#
$F4#
#
.LET $=$#
$F3#
#
.SET $=$#
$24$26 $F3#
#
. LABEL $#                   PASS ON A LABEL WITHOUT VALUE
.. LABEL $10#
#
. $#			     INTERCEPT PSEUDO MACHINE CODE
.. $10#
#
..$#			     OUTPUT ASSEMBLY LANGUAGE STMT
$10$F13#		       INSERT MACHINE DEPENDENT MACROS NEXT
#
.BEGIN#			     DUMMY INITIALIZATION
 BEGIN$F13#		       moved to mill2nasm CRB 08/22/2007
#
. SECT $#		     Added pseudo-op CRB 08/23/2007
 SECT $10$F13#
#
.INT $#			     INTERMEDIATE LANGUAGE OUTPUT
*$10$F13#
#
. $ =$#			     try to fix dummy array ref CRB 07/12/2013
.. $10 $21 =$20#
#
. $ $#			     INTERCEPT ABSTRACT MACHINE INST
.. $10 $21 $20#
## --------------- END OF MACROS                    ---------------
