1       * LEX.S1 -- Lexical Scanner for Small, CRB, Oct 11,2007                 
2       * Testing, CRB, Oct 24, 2012                                            
3       * Restoring State matrix to original, CRB, Oct 30, 2012                 
4       * Fix end of line detection, CRB, Jan 13, 2014                          
5       * Rewrite, CRB, Apr 2,2014                                              
6       * More mods, CRB, Apr 14, 2014                                          
7       * Distinguish between LKIND (lexical) and TKIND (token) CRB, May 15, 201
8       * Fix obo error in single character token CRB, Dec 3, 2014              
9                                                                               
10        BEGIN LEX;                                                            
11        ENTRY LEX;                                                            
12        EXTERN BUFF;                  * input line passed as global           
13        EXT PROC A2B40L;                                                      
14        EXT PROC LOOKS;                                                       
15        SET PRIM18=61;                * 18th prime used to hash ASCII chars   
16                                                                              
17      * character type codes                                                  
18      * T array is indexed by 7-bit ASCII character code using zero indexing  
19        DCL  T=( 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); * 1 space   
20        DCL T2=( 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1); * 2 alphabet
21        DCL T3=( 1, 5, 5, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5); * 3 digit   
22        DCL T4=( 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5, 5, 5, 5); * 4 quote ma
23        DCL T5=( 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2); * 5 other   
24        DCL T6=( 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5);             
25        DCL T7=( 5, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2);             
26        DCL T8=( 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 5, 5, 5, 5);             
27                                                                              
28        DCL S=30;                   * S(0) contains size                      
29          DCL S1=( 1, 2, 3, 4, 6);  * offset 0    1 spaces                    
30          DCL S2=(-1, 2, 2,-1,-1);  * offset 5    2 name                      
31          DCL S3=(-2,-2, 3,-2,-2);  * offset 10   3 integer                   
32          DCL S4=( 4, 4, 4, 5, 4);  * offset 15   4 quoted string             
33          DCL S5=(-3,-3,-3, 4,-3);  * offset 20   5 other                     
34          DCL S6=(-4,-4,-4,-4,-4);  * offset 25                               
35        DCL SROW=( 6, 0, 5,10,15,20,25); * aux offset vector                  
36                                                                              
37        DCL CTYPE;     * type of character                                    
38        DCL STATE;     * state variable                                       
39        DCL LKIND;     * lexical kind 1: name, 2: int, 3: string, 4, special  
40        DCL TKIND;     * token kind 0..7 for operators and keywords in initabl
41        DCL I;         * local character index in BUFF                        
42        DCL CHAR;      * current local character                              
43        DCL ANCHOR;    * anchor start of token non-blank characters           
44        DCL NUM;       * integer value                                        
45        DCL INDEX,WORDS;                                                      
46        DCL VAL,TAG;                                                          
47                                                                              
48      *---------------                                                        
49        PROC LEX(INEXT,LEXEME);                                               
50   1      STATE=1;     * initialize current state                             
51   1      I=INEXT;     * local index in BUFF                                  
52   1      ANCHOR=0;    * initialize no anchor                                 
53   1      NUM=0;       * integer value of token                               
54   1                                                                          
55   1      DO WHILE 1;  * process current token in BUFF                        
56   2        CHAR=BUFF(I);                                                     
57   2        IF CHAR EQ -1; THEN       * exit at end of line                   
58   3          EXIT                                                            
59   3        ENDIF                                                             
60   2        CTYPE=T(CHAR);  * get character type                              
61   2        STATE=S(SROW(STATE)+CTYPE);                                       
62   2        IF STATE NE 1; THEN       * stop skipping white space             
63   3          IF ANCHOR EQ 0; THEN                                            
64   4            ANCHOR=I;             * drop anchor                           
65   4          ENDIF                                                           
66   3        ENDIF                                                             
67   2        IF STATE EQ 3; THEN       * integer                               
68   3          NUM=10*NUM-'0'+CHAR;    * accumulate value                      
69   3        ENDIF                                                             
70   2        IF STATE LT 0; THEN       * if reached terminal state             
71   3          EXIT                    * drop out of loop                      
72   3        ENDIF                                                             
73   2        I=I+1;                    * advance to next character             
74   2      ENDDO                                                               
75   1                                                                          
76   1      INEXT=I;                    * return start index for next token     
77   1      LKIND=-STATE;               * return lexical LKIND of this token    
78   1      LEXEME=(I-ANCHOR) SHL 8 OR ANCHOR; * length and anchor              
79   1                                                                          
80   1      IF LKIND EQ 1; THEN         * name token                            
81   2        WORDS=A2B40L(LEXEME,BUFF);                                        
82   2        INDEX=LOOKS(WORDS,VAL,TAG);                                       
83   2        LEXEME(1)=INDEX;                                                  
84   2        LEXEME(2)=VAL;                                                    
85   2        LEXEME(3)=TAG;                                                    
86   2      ELSE IF LKIND EQ 2; THEN    * integer token                         
87   3        LEXEME(1)=NUM;            * return its binary value               
88   3      ELSE IF LKIND EQ 4; THEN    * special character token               
89   4  *      WORDS=BUFF(ANCHOR+1)*PRIM18;                                     
90   4        WORDS=BUFF(ANCHOR)*PRIM18; * fix obo error CRB 12/03/2014         
91   4        INDEX=LOOKS(WORDS,VAL,TAG);                                       
92   4        LEXEME(1)=INDEX;                                                  
93   4        LEXEME(2)=VAL;                                                    
94   4        LEXEME(3)=TAG;                                                    
95   4        ENDIF ENDIF ENDIF                                                 
96   1                                                                          
97   1      LEXEME=LKIND SHL 28 OR LEXEME; * use lexical LKIND from final STATE 
98   1      RETURN LKIND;               * return lexical LKIND 1..4             
99   1    ENDPROC                                                               
100  0    END                                                                   
 NO ERRORS DETECTED
