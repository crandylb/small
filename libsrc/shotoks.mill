** SHOTOKS.S1 -- Show tokens for current line, CRB, Nov 18, 2014
** 12/01/2014 CRB Moved from scan module
** 12/14/2014 CRB Add unpacked user name
** 12/22/2014 CRB Adding comments
** 12/27/2014 CRB Hacking
** 02/17/2015 CRB Fix seg fault from integer tokens
*
*  BEGIN SHOTOKS;
 BEGIN
*  ENT SHOTOKS;
 ENT  SHOTOKS
*
*  EXT TOKENS;
 EXT  TOKENS
*  EXT PROC WRITE,IFORM;
 EXT P WRITE
 EXT  IFORM
*  EXT PROC CAT2,CAT3;
 EXT P CAT2
 EXT  CAT3
*  EXT PROC B402A,GETWRD;
 EXT P B402A
 EXT  GETWRD
*  EXT BUFF;                       * use BUFF in initsym
 EXT  BUFF
*  EXT MASKV;
 EXT  MASKV
*
*  SET MAXTOK=127;                 * maximum number of tokens in a line
*  DCL OUTCH=3;
 SECT DATA
 LABEL OUTCH
 CONST  3
*  DCL LKIND;                      * lexical KIND code
 SECT DATA
 LABEL LKIND
 SPACE  1
*  DCL TOKNUM;                     * current token index
 SECT DATA
 LABEL TOKNUM
 SPACE  1
*  DCL TOKEN;
 SECT DATA
 LABEL TOKEN
 SPACE  1
*  DCL SUBSTR,OP;
 SECT DATA
 LABEL SUBSTR
 SPACE  1
 LABEL OP
 SPACE  1
*  DCL DEBUG(MAXTOK),TMP(31);
 SECT DATA
 LABEL DEBUG
 SPACE  128
 LABEL TMP
 SPACE  32
*  MSG SPACES='                   ';
 SECT DATA
 LABEL SPACES
 CONST  19
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
 CONST  32
*  DCL B40;
 SECT DATA
 LABEL B40
 SPACE  1
*  SET PRIM18=61;
*
*PROC SHOTOKS;                     * show tokens for current line
 SECT CODE
 SUBR P SHOTOKS
 NPARS  0
 PEND
*  TOKNUM=1;
*.GEN =TOKNUM,=1,.BNST,
 L  =1
 ST  TOKNUM
*  DO WHILE TOKNUM LE 4*TOKENS;
 LABEL LJ1
*.GEN TOKNUM,=4,TOKENS,.BC*,.BN-,
 L  =4
 *  TOKENS
 ST  T1Z
 L  TOKNUM
 -  T1Z
 JGT  LJ2
*    TOKEN=TOKENS(TOKNUM);
*.GEN =TOKEN,=TOKENS,TOKNUM,=2,.BNSHL,.BC+,.UA,.BNST,
 L  TOKNUM
 SHL  =2
 +  =TOKENS
 L  *.AC
 ST  TOKEN
*    LKIND=(TOKEN SHR 28) AND 15;
*.GEN =LKIND,TOKEN,=28,.BNSHR,=15,.BCAND,.BNST,
 L  TOKEN
 SHR  =28
 AND  =15
 ST  LKIND
*    DEBUG(1)=LKIND+'0';
*.GEN =DEBUG,=1,=2,.BNSHL,.BC+,LKIND,=48,.BC+,.BNST,
 L  =1
 SHL  =2
 +  =DEBUG
 ST  T1Z1
 L  LKIND
 +  =48
 ST  *T1Z1
*    DEBUG(2)=' ';
*.GEN =DEBUG,=2,=2,.BNSHL,.BC+,=32,.BNST,
 L  =2
 SHL  =2
 +  =DEBUG
 ST  T1Z
 L  =32
 ST  *T1Z
*    DEBUG(3)=' ';
*.GEN =DEBUG,=3,=2,.BNSHL,.BC+,=32,.BNST,
 L  =3
 SHL  =2
 +  =DEBUG
 ST  T1Z
 L  =32
 ST  *T1Z
*    DEBUG=3;
*.GEN =DEBUG,=3,.BNST,
 L  =3
 ST  DEBUG
*    SUBSTR=TOKEN AND MASKV;
*.GEN =SUBSTR,TOKEN,MASKV,.BCAND,.BNST,
 L  TOKEN
 AND  MASKV
 ST  SUBSTR
*    CALL CAT3(DEBUG,SUBSTR,BUFF);
 SCALL  CAT3
 NARGS  3
 ARG  DEBUG
 ARG  SUBSTR
 ARG  BUFF
 CEND
*    CALL CAT2(DEBUG,SPACES);
 SCALL P CAT2
 NARGS  2
 ARG  DEBUG
 ARG  SPACES
 CEND
*    DEBUG=14;
*.GEN =DEBUG,=14,.BNST,
 L  =14
 ST  DEBUG
*
*    TMP=10;                       * set size of TMP
*.GEN =TMP,=10,.BNST,
 L  =10
 ST  TMP
*    CASE LKIND-1; OF SL1,SL2,SL3,SL4;
*.GEN LKIND,=1,.BN-,=0,.BN-,
 L  LKIND
 -  =1
 -  =0
 JX  5
 JC  SL1
 JC  SL2
 JC  SL3
 JC  SL4
*LABEL SL1; GO TO SL4;             * symbol
 SECT CODE
 J  LJ5
 LABEL SL1
 J  SL4
*LABEL SL2;                        * integer
 SECT CODE
 J  LJ5
 LABEL SL2
*      TOKEN=TOKENS(TOKNUM+1);     * get integer's value
*.GEN =TOKEN,=TOKENS,TOKNUM,=1,.BC+,=2,.BNSHL,.BC+,.UA,.BNST,
 L  TOKNUM
 +  =1
 SHL  =2
 +  =TOKENS
 L  *.AC
 ST  TOKEN
*LABEL SL3;                        * quote string
 SECT CODE
 J  LJ5
 LABEL SL3
*      TOKEN=BUFF(TOKEN AND 255);  * extract first char
*.GEN =TOKEN,=BUFF,TOKEN,=255,.BCAND,=2,.BNSHL,.BC+,.UA,.BNST,
 L  TOKEN
 AND  =255
 SHL  =2
 +  =BUFF
 L  *.AC
 ST  TOKEN
*LABEL SL4;                        * single character token
 SECT CODE
 J  LJ5
 LABEL SL4
*      TOKEN=TOKENS(TOKNUM+1);     * INDEX of user symbol
*.GEN =TOKEN,=TOKENS,TOKNUM,=1,.BC+,=2,.BNSHL,.BC+,.UA,.BNST,
 L  TOKNUM
 +  =1
 SHL  =2
 +  =TOKENS
 L  *.AC
 ST  TOKEN
*    ENDCASE 
 LABEL LJ5
*
*    CALL IFORM(TOKEN,TMP);        * VAL, OP or INDEX
 SCALL  IFORM
 NARGS  2
 ARG  TOKEN
 ARG  TMP
 CEND
*    CALL CAT2(DEBUG,TMP);
 SCALL P CAT2
 NARGS  2
 ARG  DEBUG
 ARG  TMP
 CEND
*    DEBUG=DEBUG+1;                * add one more space
*.GEN =DEBUG,DEBUG,=1,.BC+,.BNST,
 L  DEBUG
 +  =1
 ST  DEBUG
*    DEBUG(DEBUG)=' ';             * for a blank separator
*.GEN =DEBUG,DEBUG,=2,.BNSHL,.BC+,=32,.BNST,
 L  DEBUG
 SHL  =2
 +  =DEBUG
 ST  T1Z
 L  =32
 ST  *T1Z
*    IF LKIND EQ 1; THEN 
*.GEN LKIND,=1,.BN-,
 L  LKIND
 -  =1
 JNE  LJ8
*        CALL GETWRD(TOKEN,B40);   * get base 40 name code
 SCALL  GETWRD
 NARGS  2
 ARG  TOKEN
 ARG  B40
 CEND
*        TMP=0;
*.GEN =TMP,=0,.BNST,
 L  =0
 ST  TMP
*        CALL B402A(B40,TMP);      * convert B40 code to ASCII
 SCALL P B402A
 NARGS  2
 ARG  B40
 ARG  TMP
 CEND
*      ELSE IF LKIND EQ 4; THEN 
 J  LJ11
 LABEL LJ8
*.GEN LKIND,=4,.BN-,
 L  LKIND
 -  =4
 JNE  LJ12
*        CALL GETWRD(TOKEN,B40);   * get hash base code special char
 SCALL  GETWRD
 NARGS  2
 ARG  TOKEN
 ARG  B40
 CEND
*        TMP=1;
*.GEN =TMP,=1,.BNST,
 L  =1
 ST  TMP
*        TMP(1)=B40/PRIM18;        * convert special char to ASCII
*.GEN =TMP,=1,=2,.BNSHL,.BC+,B40,PRIM18,.BN/,.BNST,
 L  =1
 SHL  =2
 +  =TMP
 ST  T1Z1
 L  B40
 / 61 PRIM18
 ST  *T1Z1
*      ELSE GO TO SL5;
 J  LJ14
 LABEL LJ12
 J  SL5
*      ENDIF ENDIF  
 LABEL LJ14
 LABEL LJ11
*    CALL CAT2(DEBUG,TMP);
 SCALL P CAT2
 NARGS  2
 ARG  DEBUG
 ARG  TMP
 CEND
*LABEL SL5;
 SECT CODE
 LABEL SL5
*    CALL WRITE(OUTCH,DEBUG);
 SCALL P WRITE
 NARGS  2
 ARG  OUTCH
 ARG  DEBUG
 CEND
*    TOKNUM=TOKNUM+4;
*.GEN =TOKNUM,TOKNUM,=4,.BC+,.BNST,
 L  TOKNUM
 +  =4
 ST  TOKNUM
*  ENDDO
 J  LJ1
 LABEL LJ2
*  RETURN
 RETN  SHOTOKS,0
*ENDPROC
 SECT DATA
 LABEL T1Z
 SPACE  2
 SECT CODE
 SECT DATA
 LABEL T1Z1
 SPACE  1
 SECT CODE
*
*END
 END
