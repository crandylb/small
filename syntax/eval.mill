** eval.s1 -- Britten's Archaic Expression Evaluator, CRB, Sep 23, 2014
** 09/29/2014 CRB tinkered with the coding
** 10/20/2014 CRB more tinkering
** 03/09/2015 CRB Add STP reinitialization
** 03/11/2015 CRB RETURN EXPR after UNTIL ISASEMI
** 03/15/2015 CRB Delete extraneous PCOUNT after ISAINT
** 03/15/2015 CRB Add LABB
** 03/16/2015 CRB Add LABO
** 03/20/2015 CRB Advance IT after semicolon
** 04/23/2015 CRB Add symbolic operands and error messages
** 05/03/2015 CRB Fix logical structure error
** 05/06/2015 CRB Add error messages
** 05/22/2015 CRB Add another error message
** 05/31/2015 CRB Use ISASET instead of ISASYM
*
*BEGIN EVAL;
 BEGIN
*
*  ENT EVAL;
 ENT  EVAL
*  EXT ERRCNT;                   * global error counter
 EXT  ERRCNT
*  EXT TOKENS;
 EXT  TOKENS
*  EXT MASKV;
 EXT  MASKV
*  EXT PROC ISAINT;
 EXT P ISAINT
*  EXT PROC ISASET;
 EXT P ISASET
*  EXT PROC ISAPLU;
 EXT P ISAPLU
*  EXT PROC ISAMIN;
 EXT P ISAMIN
*  EXT PROC ISAAST;
 EXT P ISAAST
*  EXT PROC ISASLA;
 EXT P ISASLA
*  EXT PROC ISALP;
 EXT P ISALP
*  EXT PROC ISARP;
 EXT P ISARP
*  EXT PROC ISASEMI;
 EXT P ISASEMI
*  EXT PROC GETS;
 EXT P GETS
*  EXT PROC ERROR;
 EXT P ERROR
*
*  SET PLUS=43;                  * ASCII +
*  SET MINUS=45;                 * ASCII -
*  SET STAR=42;                  * ASCII *
*  SET SLASH=47;                 * ASCII /
*  SET LPAREN=40;                * ASCII left parenthesis
*  SET RPAREN=41;                * ASCII right parenthesis
*
*  DCL AOP,MOP;                  * add operator, mult operator
 SECT DATA
 LABEL AOP
 SPACE  1
 LABEL MOP
 SPACE  1
*  DCL NUMB,TERM=1,EXPR=0;
 SECT DATA
 LABEL NUMB
 SPACE  1
 LABEL TERM
 CONST  1
 LABEL EXPR
 CONST  0
*  DCL PCOUNT;                   * parenthesis level count
 SECT DATA
 LABEL PCOUNT
 SPACE  1
*  DCL VAL,TAG;
 SECT DATA
 LABEL VAL
 SPACE  1
 LABEL TAG
 SPACE  1
*  MSG ERROPD=' Operand expected';
 SECT DATA
 LABEL ERROPD
 CONST  17
 CONST  32
 CONST  79
 CONST  112
 CONST  101
 CONST  114
 CONST  97
 CONST  110
 CONST  100
 CONST  32
 CONST  101
 CONST  120
 CONST  112
 CONST  101
 CONST  99
 CONST  116
 CONST  101
 CONST  100
*  MSG ERROPR=' Operator expected';
 SECT DATA
 LABEL ERROPR
 CONST  18
 CONST  32
 CONST  79
 CONST  112
 CONST  101
 CONST  114
 CONST  97
 CONST  116
 CONST  111
 CONST  114
 CONST  32
 CONST  101
 CONST  120
 CONST  112
 CONST  101
 CONST  99
 CONST  116
 CONST  101
 CONST  100
*  MSG ERRMRP=' Missing right paren'; 
 SECT DATA
 LABEL ERRMRP
 CONST  20
 CONST  32
 CONST  77
 CONST  105
 CONST  115
 CONST  115
 CONST  105
 CONST  110
 CONST  103
 CONST  32
 CONST  114
 CONST  105
 CONST  103
 CONST  104
 CONST  116
 CONST  32
 CONST  112
 CONST  97
 CONST  114
 CONST  101
 CONST  110
*  MSG ERREXP=' Extra right paren';
 SECT DATA
 LABEL ERREXP
 CONST  18
 CONST  32
 CONST  69
 CONST  120
 CONST  116
 CONST  114
 CONST  97
 CONST  32
 CONST  114
 CONST  105
 CONST  103
 CONST  104
 CONST  116
 CONST  32
 CONST  112
 CONST  97
 CONST  114
 CONST  101
 CONST  110
*  MSG ERRMTR=' Missing terminator';
 SECT DATA
 LABEL ERRMTR
 CONST  19
 CONST  32
 CONST  77
 CONST  105
 CONST  115
 CONST  115
 CONST  105
 CONST  110
 CONST  103
 CONST  32
 CONST  116
 CONST  101
 CONST  114
 CONST  109
 CONST  105
 CONST  110
 CONST  97
 CONST  116
 CONST  111
 CONST  114
*  SET STKSIZ=4*30;              * stack size
*  DCL STP=0;                    * stack pointer
 SECT DATA
 LABEL STP
 CONST  0
*  DCL STK(STKSIZ);              * push down stack
 SECT DATA
 LABEL STK
 SPACE  121
*
** evaluate infix expression starting at IT in TOKENS array
*  PROC EVAL(IT);
 SECT CODE
 SUBR P EVAL
 NPARS  1
 PAR  IT
 PEND
*    PCOUNT=0;
*.GEN =PCOUNT,=0,.BNST,
 L  =0
 ST  PCOUNT
*    STP=0;
*.GEN =STP,=0,.BNST,
 L  =0
 ST  STP
*LABEL LABA;
 SECT CODE
 LABEL LABA
*    AOP=0;
*.GEN =AOP,=0,.BNST,
 L  =0
 ST  AOP
*    MOP=0;
*.GEN =MOP,=0,.BNST,
 L  =0
 ST  MOP
*    TERM=1;
*.GEN =TERM,=1,.BNST,
 L  =1
 ST  TERM
*    EXPR=0;
*.GEN =EXPR,=0,.BNST,
 L  =0
 ST  EXPR
** process unary plus or minus
*    IF ISAPLU(IT); THEN AOP=PLUS; IT=IT+4;
*.GEN (IT),.UFISAPLU,=0,.BN-,
 ARGT D IT
 SCALL P ISAPLU
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ2
*.GEN =AOP,PLUS,.BNST,
 L 43 PLUS
 ST  AOP
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
*      ELSE IF ISAMIN(IT); THEN AOP=MINUS; IT=IT+4;
 J  LJ3
 LABEL LJ2
*.GEN (IT),.UFISAMIN,=0,.BN-,
 ARGT D IT
 SCALL P ISAMIN
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ5
*.GEN =AOP,MINUS,.BNST,
 L 45 MINUS
 ST  AOP
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
*      ENDIF ENDIF
 LABEL LJ5
 LABEL LJ3
*LABEL LABB;
 SECT CODE
 LABEL LABB
*    IF ISALP(IT); THEN          * left parenthesis
*.GEN (IT),.UFISALP,=0,.BN-,
 ARGT D IT
 SCALL P ISALP
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ7
*      IT=IT+4;
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
*      PCOUNT=PCOUNT+1;
*.GEN =PCOUNT,PCOUNT,=1,.BC+,.BNST,
 L  PCOUNT
 +  =1
 ST  PCOUNT
*      STK(STP)=AOP; STP=STP+1;  * push context
*.GEN =STK,STP,=2,.BNSHL,.BC+,AOP,.BNST,
 L  STP
 SHL  =2
 +  =STK
 ST  T1Z
 L  AOP
 ST  *T1Z
*.GEN =STP,STP,=1,.BC+,.BNST,
 L  STP
 +  =1
 ST  STP
*      STK(STP)=MOP; STP=STP+1;
*.GEN =STK,STP,=2,.BNSHL,.BC+,MOP,.BNST,
 L  STP
 SHL  =2
 +  =STK
 ST  T1Z
 L  MOP
 ST  *T1Z
*.GEN =STP,STP,=1,.BC+,.BNST,
 L  STP
 +  =1
 ST  STP
*      STK(STP)=EXPR; STP=STP+1;
*.GEN =STK,STP,=2,.BNSHL,.BC+,EXPR,.BNST,
 L  STP
 SHL  =2
 +  =STK
 ST  T1Z
 L  EXPR
 ST  *T1Z
*.GEN =STP,STP,=1,.BC+,.BNST,
 L  STP
 +  =1
 ST  STP
*      STK(STP)=TERM; STP=STP+1;
*.GEN =STK,STP,=2,.BNSHL,.BC+,TERM,.BNST,
 L  STP
 SHL  =2
 +  =STK
 ST  T1Z
 L  TERM
 ST  *T1Z
*.GEN =STP,STP,=1,.BC+,.BNST,
 L  STP
 +  =1
 ST  STP
*      GO TO LABA;
 J  LABA
*      ENDIF
 LABEL LJ7
** process operand [needs rewrite]
*    IF ISAINT(IT); THEN 
*.GEN (IT),.UFISAINT,=0,.BN-,
 ARGT D IT
 SCALL P ISAINT
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ9
*        NUMB=TOKENS(IT+1);      * get value of integer operand
*.GEN =NUMB,=TOKENS,IT,=1,.BC+,=2,.BNSHL,.BC+,.UA,.BNST,
 L D IT
 +  =1
 SHL  =2
 +  =TOKENS
 L  *.AC
 ST  NUMB
*        IT=IT+4;
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
*      ELSE IF ISASET(IT); THEN 
 J  LJ10
 LABEL LJ9
*.GEN (IT),.UFISASET,=0,.BN-,
 ARGT D IT
 SCALL P ISASET
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ12
*        NUMB=TOKENS(IT+1);      * get value of symbolic operand
*.GEN =NUMB,=TOKENS,IT,=1,.BC+,=2,.BNSHL,.BC+,.UA,.BNST,
 L D IT
 +  =1
 SHL  =2
 +  =TOKENS
 L  *.AC
 ST  NUMB
*        IT=IT+4;
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
*        CALL GETS(NUMB,VAL,TAG);
 SCALL P GETS
 NARGS  3
 ARG  NUMB
 ARG  VAL
 ARG  TAG
 CEND
*        NUMB=VAL AND MASKV;
*.GEN =NUMB,VAL,MASKV,.BCAND,.BNST,
 L  VAL
 AND  MASKV
 ST  NUMB
*      ELSE                      * operand expected error
 J  LJ14
 LABEL LJ12
*        ERRCNT=ERRCNT+1;        * bump error count
*.GEN =ERRCNT,ERRCNT,=1,.BC+,.BNST,
 L  ERRCNT
 +  =1
 ST  ERRCNT
*        CALL ERROR(IT,ERROPD);
 ARGT D IT
 SCALL P ERROR
 NARGS  2
 ARG D IT
 ARG  ERROPD
 CEND
*        GO TO LABP;
 J  LABP
*      ENDIF ENDIF
 LABEL LJ14
 LABEL LJ10
*
*LABEL LABO;                     * operator process loop
 SECT CODE
 LABEL LABO
*    REPEAT 
 LABEL LJ16
*      IF IT/4 GE TOKENS; THEN   * check for end of tokens list
*.GEN IT,=4,.BN/,TOKENS,.BN-,
 L D IT
 /  =4
 -  TOKENS
 JLT  LJ18
*        ERRCNT=ERRCNT+1;
*.GEN =ERRCNT,ERRCNT,=1,.BC+,.BNST,
 L  ERRCNT
 +  =1
 ST  ERRCNT
*        CALL ERROR(IT,ERRMTR);  * missing terminator
 ARGT D IT
 SCALL P ERROR
 NARGS  2
 ARG D IT
 ARG  ERRMTR
 CEND
*        GO TO LABP;             * error exit
 J  LABP
*        ENDIF
 LABEL LJ18
*      IF MOP EQ STAR; THEN TERM=TERM*NUMB;              * do multiply
*.GEN MOP,STAR,.BN-,
 L  MOP
 - 42 STAR
 JNE  LJ20
*.GEN =TERM,TERM,NUMB,.BC*,.BNST,
 L  TERM
 *  NUMB
 ST  TERM
*        ELSE IF MOP EQ SLASH; THEN TERM=TERM/NUMB;      * do divide
 J  LJ21
 LABEL LJ20
*.GEN MOP,SLASH,.BN-,
 L  MOP
 - 47 SLASH
 JNE  LJ22
*.GEN =TERM,TERM,NUMB,.BN/,.BNST,
 L  TERM
 /  NUMB
 ST  TERM
*        ELSE TERM=NUMB;
 J  LJ23
 LABEL LJ22
*.GEN =TERM,NUMB,.BNST,
 L  NUMB
 ST  TERM
*        ENDIF ENDIF
 LABEL LJ23
 LABEL LJ21
*      MOP=0;
*.GEN =MOP,=0,.BNST,
 L  =0
 ST  MOP
** process multiplicative operator
*      IF ISAAST(IT); THEN MOP=STAR; IT=IT+4; GO TO LABB;
*.GEN (IT),.UFISAAST,=0,.BN-,
 ARGT D IT
 SCALL P ISAAST
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ25
*.GEN =MOP,STAR,.BNST,
 L 42 STAR
 ST  MOP
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
 J  LABB
*        ELSE IF ISASLA(IT); THEN MOP=SLASH; IT=IT+4; GO TO LABB;
 J  LJ26
 LABEL LJ25
*.GEN (IT),.UFISASLA,=0,.BN-,
 ARGT D IT
 SCALL P ISASLA
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ28
*.GEN =MOP,SLASH,.BNST,
 L 47 SLASH
 ST  MOP
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
 J  LABB
*        ENDIF ENDIF
 LABEL LJ28
 LABEL LJ26
*      IF AOP EQ PLUS; THEN EXPR=EXPR+TERM;              * do add
*.GEN AOP,PLUS,.BN-,
 L  AOP
 - 43 PLUS
 JNE  LJ29
*.GEN =EXPR,EXPR,TERM,.BC+,.BNST,
 L  EXPR
 +  TERM
 ST  EXPR
*        ELSE IF AOP EQ MINUS; THEN EXPR=EXPR-TERM;      * do subtract
 J  LJ30
 LABEL LJ29
*.GEN AOP,MINUS,.BN-,
 L  AOP
 - 45 MINUS
 JNE  LJ31
*.GEN =EXPR,EXPR,TERM,.BN-,.BNST,
 L  EXPR
 -  TERM
 ST  EXPR
*        ELSE EXPR=TERM;
 J  LJ32
 LABEL LJ31
*.GEN =EXPR,TERM,.BNST,
 L  TERM
 ST  EXPR
*        ENDIF ENDIF
 LABEL LJ32
 LABEL LJ30
*      AOP=0;
*.GEN =AOP,=0,.BNST,
 L  =0
 ST  AOP
** process additive operator
*      IF ISAPLU(IT); THEN AOP=PLUS; IT=IT+4; GO TO LABB;
*.GEN (IT),.UFISAPLU,=0,.BN-,
 ARGT D IT
 SCALL P ISAPLU
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ34
*.GEN =AOP,PLUS,.BNST,
 L 43 PLUS
 ST  AOP
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
 J  LABB
*        ELSE IF ISAMIN(IT); THEN AOP=MINUS; IT=IT+4; GO TO LABB;
 J  LJ35
 LABEL LJ34
*.GEN (IT),.UFISAMIN,=0,.BN-,
 ARGT D IT
 SCALL P ISAMIN
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ37
*.GEN =AOP,MINUS,.BNST,
 L 45 MINUS
 ST  AOP
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
 J  LABB
*        ENDIF ENDIF
 LABEL LJ37
 LABEL LJ35
*      IF ISARP(IT); THEN        * right parenthesis
*.GEN (IT),.UFISARP,=0,.BN-,
 ARGT D IT
 SCALL P ISARP
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ39
*        IT=IT+4;
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
*        PCOUNT=PCOUNT-1;
*.GEN =PCOUNT,PCOUNT,=1,.BN-,.BNST,
 L  PCOUNT
 -  =1
 ST  PCOUNT
*        NUMB=EXPR;              * promote result and pop context
*.GEN =NUMB,EXPR,.BNST,
 L  EXPR
 ST  NUMB
*        IF PCOUNT GE 0; THEN    * stack pointer valid
*.GEN PCOUNT,=0,.BN-,
 L  PCOUNT
 -  =0
 JLT  LJ40
*          STP=STP-1; TERM=STK(STP);
*.GEN =STP,STP,=1,.BN-,.BNST,
 L  STP
 -  =1
 ST  STP
*.GEN =TERM,=STK,STP,=2,.BNSHL,.BC+,.UA,.BNST,
 L  STP
 SHL  =2
 +  =STK
 L  *.AC
 ST  TERM
*          STP=STP-1; EXPR=STK(STP);
*.GEN =STP,STP,=1,.BN-,.BNST,
 L  STP
 -  =1
 ST  STP
*.GEN =EXPR,=STK,STP,=2,.BNSHL,.BC+,.UA,.BNST,
 L  STP
 SHL  =2
 +  =STK
 L  *.AC
 ST  EXPR
*          STP=STP-1; MOP=STK(STP);
*.GEN =STP,STP,=1,.BN-,.BNST,
 L  STP
 -  =1
 ST  STP
*.GEN =MOP,=STK,STP,=2,.BNSHL,.BC+,.UA,.BNST,
 L  STP
 SHL  =2
 +  =STK
 L  *.AC
 ST  MOP
*          STP=STP-1; AOP=STK(STP);
*.GEN =STP,STP,=1,.BN-,.BNST,
 L  STP
 -  =1
 ST  STP
*.GEN =AOP,=STK,STP,=2,.BNSHL,.BC+,.UA,.BNST,
 L  STP
 SHL  =2
 +  =STK
 L  *.AC
 ST  AOP
*          ENDIF
 LABEL LJ40
*        GO TO LABO;             * continue operator loop
 J  LABO
*        ENDIF
 LABEL LJ39
*
*      UNTIL ISASEMI(IT);        * end of expression
*.GEN (IT),.UFISASEMI,=0,.BN-,
 ARGT D IT
 SCALL P ISASEMI
 NARGS  1
 ARG D IT
 CEND
 -  =0
 JEQ  LJ16
 LABEL LJ17
*
*    IT=IT+4;
*.GEN =IT,IT,=4,.BC+,.BNST,
 L D IT
 +  =4
 ST D IT
*    IF PCOUNT; THEN ERRCNT=ERRCNT+1;
*.GEN PCOUNT,=0,.BN-,
 L  PCOUNT
 -  =0
 JEQ  LJ42
*.GEN =ERRCNT,ERRCNT,=1,.BC+,.BNST,
 L  ERRCNT
 +  =1
 ST  ERRCNT
*      IF PCOUNT GT 0; THEN      * check for balanced parens
*.GEN PCOUNT,=0,.BN-,
 L  PCOUNT
 -  =0
 JLE  LJ43
*        CALL ERROR(IT,ERRMRP);  * missing right paren
 ARGT D IT
 SCALL P ERROR
 NARGS  2
 ARG D IT
 ARG  ERRMRP
 CEND
*        GO TO LABP;
 J  LABP
*      ELSE 
 J  LJ45
 LABEL LJ43
*        CALL ERROR(IT,ERREXP);  * extra right paren
 ARGT D IT
 SCALL P ERROR
 NARGS  2
 ARG D IT
 ARG  ERREXP
 CEND
*        GO TO LABP;
 J  LABP
*      ENDIF ENDIF
 LABEL LJ45
 LABEL LJ42
*    RETURN EXPR;                * return expression value
*.GEN EXPR,
 L  EXPR
 RETN  EVAL,1
*
*LABEL LABP;
 SECT CODE
 LABEL LABP
*    RETURN 0;                   * error return
*.GEN =0,
 L  =0
 RETN  EVAL,1
*  ENDPROC
 SECT DATA
 LABEL T1Z
 SPACE  2
 SECT CODE
*
*END
 END
