1       * SYMACC.S1 -- Symbol Table Access Module for Small, CRB, Feb 9, 2014   
2                                                                               
3       BEGIN SYMACC;                                                           
4       * Symbols are stored in an array called TABLE that is indexed by a hash 
5       * function on the first six characters of a name. Each symbol occupies  
6       * two 32-bit words in the table. The first word contains the compressed 
7       * base 40 representation of the symbol, and the second word contains the
8       * 16-bit VAL and TAG words.                                             
9                                                                               
10        ENTRY LOOKS,GETS,PUTS,GETWRD; * symbol table acces procedures         
11        ENTRY A2B40,B402A;            * ASCII, B40 conversion                 
12                                                                              
13        SET TABSIZ=8191;              * prime < 2^13                          
14        DCL TABLE(TABSIZ);            * table < 2^16 bytes, 4094 symbols      
15        DCL STRING(6);                * space to hold converted ASCII string  
16        DCL I,J,CHAR,LEN,B,CODE;      * local variables                       
17        DCL MASKE=-2;                 * mask for even number                  
18        DCL MASKV=65535;              * mask for low 16 bits                  
19                                                                              
20      * Convert ASCII STR to base 40 CODE packing 6 characters in 32 bit word 
21      * Only upper case letters and decimal digits are allowed                
22      * Return the 32-bit CODE value                                          
23      ******************************                                          
24      PROC A2B40(STR);                * convert ASCII string to base 40       
25   1    LEN=STR;                      * get length of string                  
26   1    IF LEN GT 6; THEN                                                     
27   2      LEN=6;                      * truncate length to 6                  
28   2      ENDIF                                                               
29   1    I=LEN;                                                                
30   1    CODE=0;                       * init B40 code                         
31   1    DO WHILE I GT 0;                                                      
32   2      CHAR=STR(I);                * read charaters in reverse order       
33   2      IF CHAR LE 57; THEN                                                 
34   3        B=CHAR-21;                * digits 0..9 -> 27..36                 
35   3      ELSE IF CHAR LE 90; THEN                                            
36   4        B=CHAR-64;                * upper case A..Z -> 1..26              
37   4      ELSE IF CHAR LE 122; THEN                                           
38   5        B=CHAR-96;                * lower case a..z -> 1..26              
39   5        ENDIF ENDIF ENDIF                                                 
40   2      CODE=40*CODE+B;             * calculate base 40 code                
41   2      I=I-1;                      * decrement I for next character        
42   2      ENDDO                                                               
43   1    RETURN CODE;                  * return accumulated base 40 code       
44   1    ENDPROC                                                               
45   0                                                                          
46   0  * Convert base 40 code to ASCII in NAME                                 
47   0  * No return value                                                       
48   0  *****************                                                       
49   0  PROC B402A(B40,NAME);           * convert base 40 to ASCII string       
50   1    B=B40;                                                                
51   1    I=0;                                                                  
52   1    DO WHILE I LT 6;                                                      
53   2      I=I+1;                                                              
54   2      CHAR=B MOD 40;                                                      
55   2      B=B/40;                                                             
56   2      IF CHAR EQ 0;                                                       
57   3        THEN EXIT                                                         
58   3        ENDIF                                                             
59   2      IF CHAR LE 26;                                                      
60   3        THEN CHAR=CHAR+64;        * upper case letter                     
61   3        ELSE CHAR=CHAR+21;        * decimal digit                         
62   3        ENDIF                                                             
63   2       NAME(I)=CHAR;              * put character in name string          
64   2       ENDDO                                                              
65   1    NAME=I;                       * set string length                     
66   1    RETURN                                                                
67   1    ENDPROC                                                               
68   0                                                                          
69   0  * Look up a packed symbol (WORDS) in TABLE                              
70   0  * Insert the new symbol with VAL and TAG if not already in TABLE        
71   0  * If collision use next empty slot, if TABLE full return -1             
72   0  * If existing entry found return VAL and TAG from TABLE                 
73   0  * Return value is index of entry in TABLE                               
74   0  *****************************************                               
75   0  PROC LOOKS(WORDS,VAL,TAG);      * look up or insert symbol              
76   1    MASKV=(32767 SHL 1) OR 1;     * fudge correct value of mask           
77   1    I=WORDS MOD TABSIZ;                                                   
78   1    I=I AND MASKE;                * use only even index                   
79   1    J=I;                          * save starting position                
80   1    REPEAT                                                                
81   2      IF TABLE(I) EQ 0;           * found empty slot                      
82   3        THEN TABLE(I)=WORDS;                                              
83   3          TABLE(I+1)=(TAG SHL 16) OR VAL;                                 
84   3          RETURN I;                                                       
85   3        ELSE IF TABLE(I) EQ WORDS; * found match                          
86   4        THEN B=TABLE(I+1);                                                
87   4          VAL=B AND MASKV;                                                
88   4          TAG=(B SHR 16) AND MASKV;                                       
89   4          RETURN I;                                                       
90   4        ENDIF ENDIF                                                       
91   2      I=I+2;                      * try next slot                         
92   2      IF I GT TABSIZ;                                                     
93   3        THEN I=I-TABSIZ;                                                  
94   3        ENDIF                                                             
95   2      UNTIL I EQ J;               * check for wrap to starting position   
96   1    RETURN -1;                    * table full                            
97   1    ENDPROC                                                               
98   0                                                                          
99   0  * Get VAL and TAG for this INDEX in TABLE                               
100  0  * No return value                                                       
101  0  *****************                                                       
102  0  PROC GETS(INDEX,VAL,TAG);       * get VAL and TAG for INDEX             
103  1    B=TABLE(INDEX+1);                                                     
104  1    VAL=B AND MASKV;              * get VAL part                          
105  1    TAG=(B SHR 16) AND MASKV;     * get TAG part                          
106  1    RETURN                                                                
107  1    ENDPROC                                                               
108  0                                                                          
109  0  * Put new VAL and TAG for this INDEX in TABLE                           
110  0  * No return value                                                       
111  0  *****************                                                       
112  0  PROC PUTS(PINDEX,VAL,TAG);      * put VAL and TAG at INDEX              
113  1    TABLE(PINDEX+1)=(TAG SHL 16) OR VAL;                                  
114  1    RETURN                                                                
115  1    ENDPROC                                                               
116  0                                                                          
117  0  * Get packed symbol (WDS) for this index in TABLE                       
118  0  * No return value                                                       
119  0  *****************                                                       
120  0  PROC GETWRD(INDEX,WDS);        * get base 40 code at INDEX              
121  1    WDS=TABLE(INDEX);                                                     
122  1    RETURN                                                                
123  1    ENDPROC                                                               
124  0                                                                          
125  0  END                                                                     
 NO ERRORS DETECTED
